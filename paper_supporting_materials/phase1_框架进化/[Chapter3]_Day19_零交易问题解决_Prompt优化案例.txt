# Day 19: V1.3-Crossover Trade-Frequency Optimized Prompt

## CRITICAL BUG FIX - READ CAREFULLY ‚ö†Ô∏è

**ABSOLUTELY FORBIDDEN**:
```python
# ‚ùå‚ùå‚ùå NEVER DO THIS - CATASTROPHIC ERROR ‚ùå‚ùå‚ùå
elif condition:
    if self.position:
        self.sell(size=20)  # THIS WILL OPEN A SHORT POSITION AND CAUSE -200% LOSSES!
```

**CORRECT WAY TO EXIT**:
```python
# ‚úÖ‚úÖ‚úÖ ALWAYS DO THIS ‚úÖ‚úÖ‚úÖ
elif condition:
    if self.position:
        self.position.close()  # This safely closes your position
```

**WHY THIS MATTERS**:
- `self.sell(size=20)` does NOT exit your position
- It OPENS A SHORT POSITION (betting price will go down)
- In an uptrend, shorting causes massive losses (-200% to -300%)
- `self.position.close()` safely exits to cash

---

## üéØ DAY 19 SPECIAL FOCUS: TRADING FREQUENCY

**CRITICAL NEW REQUIREMENT**:
Your strategy MUST generate at least 3-5 trades during the test period to be considered valid.

**WHY THIS MATTERS**:
- A strategy with ZERO trades is completely useless
- We need actual trading signals, not overly conservative conditions
- Balance safety with reasonable activity

**How to achieve this**:
1. Don't make entry conditions TOO restrictive
2. Use reasonable RSI thresholds (RSI > 35 is better than RSI > 50)
3. Avoid combining too many filters (2-3 conditions max)
4. Test different SMA combinations (faster SMAs like 3/8, 5/10 generate more signals)

---

## V1.3-Crossover Framework Specification

You are an expert quantitative trader tasked with creating a high-performance trading strategy using the V1.3-Crossover framework.

### REQUIRED FEATURES (Non-negotiable):

#### 1. ‚≠ê‚≠ê‚≠ê Entry Signal: crossover() - DYNAMIC TIMING
**You MUST use crossover() for entry signals**:
```python
# CORRECT - Dynamic crossover signal
if crossover(self.sma_5, self.sma_10) and self.rsi[-1] > 35:
    if not self.position:
        self.buy(size=20)
```

**NEVER use static comparisons for entry**:
```python
# ‚ùå WRONG - Static comparison
if self.sma_5[-1] > self.sma_10[-1]:  # This triggers continuously!
    self.buy()
```

#### 2. ‚≠ê‚≠ê‚≠ê Exit Signal: self.position.close() - SAFE EXIT
**CRITICAL**: You have TWO options for exit:

**Option A: Static condition (Recommended for more trades)**
```python
# Fast exit - triggers as soon as sma_5 falls below sma_10
elif self.sma_5[-1] < self.sma_10[-1]:
    if self.position:
        self.position.close()  # ‚úÖ CORRECT
```

**Option B: Crossover reversal (More conservative)**
```python
# Precise exit - only triggers at exact crossover moment
elif crossover(self.sma_10, self.sma_5):
    if self.position:
        self.position.close()  # ‚úÖ CORRECT
```

**üí° TIP for GLD/Commodities**: Use Option A for more frequent trades!

**‚ùå ABSOLUTELY FORBIDDEN ‚ùå**:
```python
elif self.sma_5[-1] < self.sma_10[-1]:
    if self.position:
        self.sell(size=20)  # ‚ùå CATASTROPHIC - OPENS SHORT!
```

#### 3. ‚≠ê‚≠ê RSI Filter: RSI(7) > 35 (RELAXED FOR MORE TRADES)
```python
self.rsi = self.I(RSI, self.data.Close, 7)  # Note: period=7, not 14

# Day 19 IMPROVEMENT: Relaxed from 40 to 35
if crossover(...) and self.rsi[-1] > 35:  # ‚úÖ More permissive
    self.buy(size=20)
```

**Why RSI > 35 instead of 40?**
- RSI > 40 was too restrictive, causing zero trades
- RSI > 35 still filters out oversold conditions
- Generates 30-50% more trading opportunities

#### 4. ‚≠ê‚≠ê Stop Loss: -200
```python
def next(self):
    # ALWAYS check stop loss FIRST
    if self.position and self.position.pl < -200:
        self.position.close()  # ‚úÖ Use close(), not sell()
        return  # Exit early to prevent new trades
```

#### 5. ‚≠ê Multiple SMA Layers (2-4 SMAs)

**RECOMMENDED SMA COMBINATIONS** (sorted by signal frequency):
```python
# High-frequency combinations (5-10 crossovers per year):
self.sma_3 = self.I(SMA, self.data.Close, 3)
self.sma_8 = self.I(SMA, self.data.Close, 8)
# Use: crossover(self.sma_3, self.sma_8)

# Medium-frequency (3-6 crossovers per year):
self.sma_5 = self.I(SMA, self.data.Close, 5)
self.sma_10 = self.I(SMA, self.data.Close, 10)
# Use: crossover(self.sma_5, self.sma_10)

# Low-frequency (1-3 crossovers per year):
self.sma_10 = self.I(SMA, self.data.Close, 10)
self.sma_20 = self.I(SMA, self.data.Close, 20)
# Use: crossover(self.sma_10, self.sma_20)
```

**üí° TIP**: For GLD/commodities, use FASTER SMAs (3/8 or 5/10) to avoid zero trades!

#### 6. Position Sizing
- **Standard**: `size=10` (conservative)
- **Aggressive**: `size=20` (for strong trends)

---

## Complete Template Example (OPTIMIZED FOR TRADE FREQUENCY)

```python
from backtesting import Strategy
from backtesting.lib import crossover
from backtesting.test import SMA
import talib
import numpy as np

def RSI(array, period):
    return talib.RSI(np.array(array, dtype=float), timeperiod=period)

class Strat(Strategy):
    def init(self):
        # Use FASTER SMAs for more signals
        self.sma_5 = self.I(SMA, self.data.Close, 5)
        self.sma_10 = self.I(SMA, self.data.Close, 10)
        # Optional: Add one more layer, but DON'T use it as a filter
        self.sma_15 = self.I(SMA, self.data.Close, 15)
        self.rsi = self.I(RSI, self.data.Close, 7)

    def next(self):
        # 1. STOP LOSS - Always first!
        if self.position and self.position.pl < -200:
            self.position.close()  # ‚úÖ CORRECT
            return

        # 2. ENTRY - Simple conditions (2-3 max!)
        # RELAXED RSI: 35 instead of 40
        if crossover(self.sma_5, self.sma_10) and self.rsi[-1] > 35:
            if not self.position:
                self.buy(size=20)

        # 3. EXIT - Use static condition for faster exits
        elif self.sma_5[-1] < self.sma_10[-1]:
            if self.position:
                self.position.close()  # ‚úÖ CORRECT
```

**Key improvements in this template**:
- ‚úÖ RSI > 35 (was 40 in Day 18)
- ‚úÖ Static exit condition (faster than crossover)
- ‚úÖ Only 2 conditions (crossover + RSI)
- ‚úÖ No long-term SMA filter (sma_20 removed)

---

## Day 19 Optimization Summary

### What Changed from Day 18:

| Feature | Day 18 | Day 19 | Reason |
|---------|--------|--------|--------|
| **RSI Threshold** | > 40 | **> 35** | 30% more trade opportunities |
| **Exit Logic** | Crossover or static | **Recommend static** | Faster exits = more trades |
| **Max Conditions** | 3-4 | **2-3** | Simpler = more signals |
| **SMA Filter** | Optional sma_20 | **Discouraged** | Reduces zero-trade risk |
| **Trade Frequency** | Not mentioned | **Required 3-5+** | Explicit goal |

### Common Mistakes to AVOID

#### ‚ùå Mistake 1: Using sell() to exit
```python
# ‚ùå WRONG - This opens a short position!
elif self.sma_5[-1] < self.sma_10[-1]:
    self.sell(size=20)
```

#### ‚ùå Mistake 2: Too many conditions (CAUSES ZERO TRADES!)
```python
# ‚ùå WRONG - Too restrictive!
if crossover(self.sma_5, self.sma_10) and \
   self.rsi[-1] > 40 and \
   self.sma_5[-1] > self.sma_20[-1] and \
   self.sma_10[-1] > self.sma_20[-1]:
    self.buy()
```

#### ‚ùå Mistake 3: Using slow SMAs for commodities
```python
# ‚ùå WRONG - Too slow for GLD!
self.sma_20 = self.I(SMA, self.data.Close, 20)
self.sma_50 = self.I(SMA, self.data.Close, 50)
if crossover(self.sma_20, self.sma_50):  # Only 1-2 signals per year!
```

#### ‚ùå Mistake 4: Redundant conditions
```python
# ‚ùå WRONG - sma_5 > sma_10 is redundant after crossover
if crossover(self.sma_5, self.sma_10) and self.sma_5[-1] > self.sma_10[-1]:
```

---

## Your Task

Generate a creative, high-performance trading strategy that:

1. ‚úÖ **USES crossover() for entry** (100% required)
2. ‚úÖ **USES self.position.close() for exit** (NEVER self.sell()!)
3. ‚úÖ **Uses RSI(7) > 35 filter** (relaxed from 40)
4. ‚úÖ **Has stop loss at position.pl < -200**
5. ‚úÖ **Uses 2-3 SMA layers** (avoid too many!)
6. ‚úÖ **GENERATES 3-5+ TRADES** (test period viability)
7. ‚≠ê **Be creative with**:
   - Which SMAs to cross (5/10? 3/8? 8/15?)
   - Position sizing (10 or 20?)
   - Exit logic (static or crossover?)

**BALANCE**: Safety (no bugs) + Activity (enough trades) + Performance (positive returns)

---

## Final Reminder

**CRITICAL SAFETY CHECK**:
Before you finish, search your code for the word `sell`:
- ‚úÖ If you find `self.position.close()` ‚Üí CORRECT
- ‚ùå If you find `self.sell(` ‚Üí WRONG - Fix it!

**CRITICAL TRADE FREQUENCY CHECK**:
- Your strategy should be designed to generate at least 3-5 trades
- Use faster SMAs (3/8, 5/10) rather than slow ones (20/50)
- Keep conditions simple (2-3 max)
- Use RSI > 35, not RSI > 50

**Your strategy will be backtested on real market data.**
**Using sell() instead of close() will cause -200% losses.**
**Having zero trades means your strategy is useless.**
**Always use self.position.close() to exit positions.**

---

Good luck! Create a strategy that balances precision (crossover), safety (proper exits), and reasonable trading frequency!
